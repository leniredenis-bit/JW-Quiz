/* ==========    frutas:     transportes: [
        { name: 'Carro', emoji: 'ðŸš—' }, { name: 'TÃ¡xi', emoji: 'ðŸš•' }, { name: 'Ã”nibus', emoji: 'ðŸšŒ' }, { name: 'AmbulÃ¢ncia', emoji: 'ðŸš‘' },
        { name: 'PolÃ­cia', emoji: 'ðŸš“' }, { name: 'CaminhÃ£o', emoji: 'ðŸšš' }, { name: 'Trator', emoji: 'ðŸšœ' }, { name: 'Bicicleta', emoji: 'ðŸš²' },
        { name: 'Moto', emoji: 'ðŸï¸' }, { name: 'AviÃ£o', emoji: 'âœˆï¸' }, { name: 'Foguete', emoji: 'ðŸš€' }, { name: 'Barco', emoji: 'â›µï¸' },
        { name: 'Navio', emoji: 'ðŸ›³ï¸' }, { name: 'Trem', emoji: 'ðŸš†' }, { name: 'HelicÃ³ptero', emoji: 'ðŸš' }, { name: 'Patinete', emoji: 'ðŸ›´' },
        { name: 'Monociclo', emoji: 'ðŸš²' }, { name: 'TelefÃ©rico', emoji: 'ðŸš ' }, { name: 'TrÃ³lebus', emoji: 'ðŸšŽ' }, { name: 'VagÃ£o', emoji: 'ðŸšƒ' }
    ],     { name: 'MaÃ§Ã£', emoji: 'ðŸŽ' }, { name: 'Banana', emoji: 'ðŸŒ' }, { name: 'Uva', emoji: 'ðŸ‡' }, { name: 'Morango', emoji: 'ðŸ“' },
        { name: 'MelÃ£o', emoji: 'ðŸˆ' }, { name: 'Cereja', emoji: 'ðŸ’' }, { name: 'PÃªssego', emoji: 'ðŸ‘' }, { name: 'Kiwi', emoji: 'ðŸ¥' },
        { name: 'Manga', emoji: 'ðŸ¥­' }, { name: 'Coco', emoji: 'ðŸ¥¥' }, { name: 'Melancia', emoji: 'ðŸ‰' }, { name: 'Laranja', emoji: 'ðŸŠ' },
        { name: 'LimÃ£o', emoji: 'ðŸ‹' }, { name: 'PÃªra', emoji: 'ðŸ' }, { name: 'Abacaxi', emoji: 'ðŸ' }, { name: 'Abacate', emoji: 'ðŸ¥‘' },
        { name: 'Amora', emoji: 'ðŸ«' }, { name: 'Figo', emoji: 'ðŸ«’' }, { name: 'RomÃ£', emoji: 'ðŸ«•' }, { name: 'Tangerina', emoji: 'ðŸŠ' }
    ],================================
   MEMORY GAME - THEME CONFIGURATION
   ================================================ */

// Para adicionar um novo tema, basta adicionar uma nova entrada aqui com 20 itens.
const THEMES = {
    animais: [
        { name: 'Cachorro', emoji: 'ðŸ¶' }, { name: 'Gato', emoji: 'ðŸ±' }, { name: 'Rato', emoji: 'ðŸ­' }, { name: 'Hamster', emoji: 'ðŸ¹' },
        { name: 'Coelho', emoji: 'ðŸ°' }, { name: 'Raposa', emoji: 'ðŸ¦Š' }, { name: 'Urso', emoji: 'ðŸ»' }, { name: 'Panda', emoji: 'ðŸ¼' },
        { name: 'CoalÃ¡', emoji: 'ðŸ¨' }, { name: 'Tigre', emoji: 'ðŸ¯' }, { name: 'LeÃ£o', emoji: 'ðŸ¦' }, { name: 'Vaca', emoji: 'ðŸ®' },
        { name: 'Porco', emoji: 'ðŸ·' }, { name: 'Sapo', emoji: 'ðŸ¸' }, { name: 'Macaco', emoji: 'ðŸµ' }, { name: 'Galinha', emoji: 'ðŸ”' },
        { name: 'Pinguim', emoji: 'ðŸ§' }, { name: 'PÃ¡ssaro', emoji: 'ðŸ¦' }, { name: 'Pato', emoji: 'ðŸ¦†' }, { name: 'Coruja', emoji: 'ðŸ¦‰' }
    ],
    frutas: [
        { name: 'MaÃ§Ã£', emoji: 'ï¿½' }, { name: 'Banana', emoji: 'ï¿½' }, { name: 'Uva', emoji: 'ï¿½' }, { name: 'Morango', emoji: 'ðŸ“' },
        { name: 'MelÃ£o', emoji: 'ðŸˆ' }, { name: 'Cereja', emoji: 'ï¿½' }, { name: 'PÃªssego', emoji: 'ï¿½' }, { name: 'Kiwi', emoji: 'ðŸ¥' },
        { name: 'Manga', emoji: 'ðŸ¥­' }, { name: 'Coco', emoji: 'ðŸ¥¥' }, { name: 'Melancia', emoji: 'ï¿½' }, { name: 'Laranja', emoji: 'ï¿½' },
        { name: 'LimÃ£o', emoji: 'ðŸ‹' }, { name: 'PÃªra', emoji: 'ï¿½' }, { name: 'Abacaxi', emoji: 'ï¿½' }
    ],
    transportes: [
        { name: 'Carro', emoji: 'ï¿½' }, { name: 'TÃ¡xi', emoji: 'ï¿½' }, { name: 'Ã”nibus', emoji: 'ï¿½' }, { name: 'AmbulÃ¢ncia', emoji: 'ï¿½' },
        { name: 'Carro de PolÃ­cia', emoji: 'ï¿½' }, { name: 'CaminhÃ£o', emoji: 'ï¿½' }, { name: 'Trator', emoji: 'ï¿½' }, { name: 'Bicicleta', emoji: 'ï¿½' },
        { name: 'Moto', emoji: 'ï¿½' }, { name: 'AviÃ£o', emoji: 'âœˆï¸' }, { name: 'Foguete', emoji: 'ï¿½' }, { name: 'Barco', emoji: 'â›µï¸' },
        { name: 'Navio', emoji: 'ðŸ›³ï¸' }, { name: 'Trem', emoji: 'ðŸš†' }, { name: 'HelicÃ³ptero', emoji: 'ðŸš' }
    ],
    peixes: [
        { name: 'Peixe', emoji: 'ðŸŸ' }, { name: 'Peixe Tropical', emoji: 'ï¿½' }, { name: 'Baiacu', emoji: 'ï¿½' }, { name: 'TubarÃ£o', emoji: 'ï¿½' },
        { name: 'Polvo', emoji: 'ï¿½' }, { name: 'Lula', emoji: 'ðŸ¦‘' }, { name: 'Lagosta', emoji: 'ðŸ¦ž' }, { name: 'Caranguejo', emoji: 'ï¿½' },
        { name: 'Concha', emoji: 'ðŸš' }, { name: 'Baleia', emoji: 'ï¿½' }, { name: 'Orca', emoji: 'ï¿½' }, { name: 'Foca', emoji: 'ï¿½' },
        { name: 'Tartaruga', emoji: 'ðŸ¢' }, { name: 'Crocodilo', emoji: 'ðŸŠ' }, { name: 'Lagarto', emoji: 'ðŸ¦Ž' }
    ],
    aves: [
        { name: 'PÃ¡ssaro', emoji: 'ðŸ¦' }, { name: 'Ãguia', emoji: 'ï¿½' }, { name: 'Coruja', emoji: 'ï¿½' }, { name: 'Pato', emoji: 'ðŸ¦†' },
        { name: 'Papagaio', emoji: 'ï¿½' }, { name: 'Galinha', emoji: 'ï¿½' }, { name: 'Pinguim', emoji: 'ï¿½' }, { name: 'PavÃ£o', emoji: 'ðŸ¦š' },
        { name: 'Cisne', emoji: 'ï¿½' }, { name: 'Peru', emoji: 'ï¿½' }, { name: 'Galo', emoji: 'ï¿½' }, { name: 'Morcego', emoji: 'ï¿½' },
        { name: 'Pardal', emoji: 'ï¿½â€â¬›' }, { name: 'DodÃ´', emoji: 'ðŸ¦¤' }, { name: 'FÃªnix', emoji: 'ðŸ¦â€ðŸ”¥' }
    ],
    numeros: [
        { name: 'Um', emoji: '1ï¸âƒ£' }, { name: 'Dois', emoji: '2ï¸âƒ£' }, { name: 'TrÃªs', emoji: '3ï¸âƒ£' }, { name: 'Quatro', emoji: '4ï¸âƒ£' },
        { name: 'Cinco', emoji: '5ï¸âƒ£' }, { name: 'Seis', emoji: '6ï¸âƒ£' }, { name: 'Sete', emoji: '7ï¸âƒ£' }, { name: 'Oito', emoji: '8ï¸âƒ£' },
        { name: 'Nove', emoji: '9ï¸âƒ£' }, { name: 'Dez', emoji: 'ðŸ”Ÿ' }, { name: 'Zero', emoji: '0ï¸âƒ£' }, { name: 'Onze', emoji: '1ï¸âƒ£1ï¸âƒ£' },
        { name: 'Doze', emoji: '1ï¸âƒ£2ï¸âƒ£' }, { name: 'Vinte', emoji: '2ï¸âƒ£0ï¸âƒ£' }, { name: 'Cem', emoji: 'ðŸ’¯' }, { name: 'Mil', emoji: '1ï¸âƒ£0ï¸âƒ£0ï¸âƒ£0ï¸âƒ£' },
        { name: 'Sinal de +', emoji: 'âž•' }, { name: 'Sinal de -', emoji: 'âž–' }, { name: 'Sinal de x', emoji: 'âœ–ï¸' }, { name: 'Sinal de Ã·', emoji: 'âž—' }
    ],
    objetos: [
        { name: 'Celular', emoji: 'ðŸ“±' }, { name: 'Computador', emoji: 'ðŸ’»' }, { name: 'RelÃ³gio', emoji: 'âŒš' }, { name: 'CÃ¢mera', emoji: 'ðŸ“·' },
        { name: 'CÃ¢mera de VÃ­deo', emoji: 'ðŸŽ¥' }, { name: 'TelevisÃ£o', emoji: 'ï¿½' }, { name: 'RÃ¡dio', emoji: 'ï¿½' }, { name: 'LÃ¢mpada', emoji: 'ï¿½' },
        { name: 'Bateria', emoji: 'ï¿½' }, { name: 'Tomada', emoji: 'ðŸ”Œ' }, { name: 'Caixa de Ferramentas', emoji: 'ðŸ› ï¸' }, { name: 'Chave Inglesa', emoji: 'ï¿½' },
        { name: 'Martelo', emoji: 'ï¿½' }, { name: 'Escada', emoji: 'ðŸªœ' }, { name: 'RÃ©gua', emoji: 'ï¿½' }, { name: 'Esquadro', emoji: 'ï¿½' },
        { name: 'Clips', emoji: 'ï¿½' }, { name: 'Tesoura', emoji: 'âœ‚ï¸' }, { name: 'Cadeado', emoji: 'ï¿½' }, { name: 'Chave', emoji: 'ï¿½ï¸' }
    ],
    natureza: [
        { name: 'Flor de Cerejeira', emoji: 'ðŸŒ¸' }, { name: 'Flor', emoji: 'ðŸŒº' }, { name: 'Girassol', emoji: 'ï¿½' }, { name: 'Flor', emoji: 'ï¿½' },
        { name: 'Rosa', emoji: 'ï¿½' }, { name: 'Margarida', emoji: 'ï¿½' }, { name: 'Folha', emoji: 'ï¿½' }, { name: 'Trevo', emoji: 'ï¿½' },
        { name: 'Ãrvore', emoji: 'ï¿½' }, { name: 'Pinheiro', emoji: 'ï¿½' }, { name: 'Palmeira', emoji: 'ï¿½' }, { name: 'Cacto', emoji: 'ï¿½' },
        { name: 'Trigo', emoji: 'ï¿½' }, { name: 'Broto', emoji: 'ï¿½' }, { name: 'Cogumelo', emoji: 'ï¿½' }, { name: 'Castanha', emoji: 'ï¿½' }
    ]
};

/* ================================================
   MEMORY GAME 2.0 - CENTRALIZED STATE & MODERN PATTERNS
   ================================================ */

// --- DOM ELEMENTS (Cached for performance) ---
const DOM = {
    gameBoard: document.getElementById('game-board'),
    statusDisplay: document.getElementById('status-display'),
    themeSelect: document.getElementById('theme-select'),
    soundToggle: document.getElementById('sound-toggle'),
    timerDisplay: document.getElementById('timer-display'),
    timerText: document.getElementById('timer-text'),
    memoryView: document.getElementById('memory-view'),
    memoryConfig: document.getElementById('memory-config'),
    memoryGame: document.getElementById('memory-game')
};

// --- CENTRALIZED GAME STATE ---
const gameState = {
    // Card management
    cards: [],
    firstCard: null,
    secondCard: null,
    lockBoard: false,
    
    // Game progress
    pairsFound: 0,
    totalPairs: 0,
    
    // Player management
    numPlayers: 1,
    currentPlayer: 0,
    scores: [0],
    
    // Timer (hard mode)
    timer: null,
    timeLeft: 0,
    
    // Settings
    difficulty: 'medium',
    theme: 'animais',
    soundEnabled: true,
    
    // Game status
    isGameActive: false,
    
    // Reset function
    reset() {
        this.cards = [];
        this.firstCard = null;
        this.secondCard = null;
        this.lockBoard = false;
        this.pairsFound = 0;
        this.totalPairs = 0;
        this.currentPlayer = 0;
        this.scores = Array(this.numPlayers).fill(0);
        this.timeLeft = 0;
        this.isGameActive = false;
        
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
    }
};

/* ================================================
   NAVIGATION & VIEW MANAGEMENT
   ================================================ */
/**
 * Hides all memory game subviews
 */
function hideAllMemorySubviews() {
    DOM.memoryConfig?.classList.remove('active');
    DOM.memoryGame?.classList.remove('active');
}

/**
 * Shows memory menu (alias for config)
 */
function showMemoryMenu() {
    showMemoryConfig();
}

/**
 * Shows configuration screen
 */
function showMemoryConfig() {
    hideAllMemorySubviews();
    DOM.memoryConfig?.classList.add('active');
}

/**
 * Shows game board screen
 */
function showMemoryGame() {
    hideAllMemorySubviews();
    DOM.memoryGame?.classList.add('active');
}

// Export functions to global scope for main.js
window.showMemoryMenu = showMemoryMenu;
window.showMemoryConfig = showMemoryConfig;
window.showMemoryGame = showMemoryGame;

/* ================================================
   GAME BOARD MANAGEMENT
   ================================================ */

/**
 * Difficulty settings
 */
const DIFFICULTY_CONFIG = {
    easy: { pairs: 10, time: 0 },
    medium: { pairs: 15, time: 0 },
    hard: { pairs: 20, time: 120 }
};

/**
 * Shuffles an array using Fisher-Yates algorithm
 * @param {Array} array - Array to shuffle
 * @returns {Array} Shuffled array
 */
function shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
}

/**
 * Creates and renders the game board
 */
function createBoard() {
    if (!DOM.gameBoard) return;
    
    // Clear previous board
    DOM.gameBoard.innerHTML = '';
    
    // Get configuration
    const { pairs } = DIFFICULTY_CONFIG[gameState.difficulty];
    gameState.totalPairs = pairs;
    gameState.pairsFound = 0;
    
    // Get theme items and create pairs with unique IDs
    const themeItems = THEMES[gameState.theme].slice(0, pairs);
    
    // Add pairId to each item before duplicating
    const itemsWithIds = themeItems.map((item, index) => ({
        ...item,
        pairId: index
    }));
    
    // Duplicate items to create pairs
    const cardItems = shuffleArray([...itemsWithIds, ...itemsWithIds]);
    
    // Create card elements
    const fragment = document.createDocumentFragment();
    
    gameState.cards = cardItems.map(item => {
        const card = createCardElement(item);
        fragment.appendChild(card);
        return card;
    });
    
    DOM.gameBoard.appendChild(fragment);
}

/**
 * Creates a single card element
 * @param {Object} item - Card data {name, emoji, pairId}
 * @returns {HTMLElement} Card element
 */
function createCardElement(item) {
    const card = document.createElement('div');
    card.classList.add('memory-card');
    card.dataset.pairId = item.pairId; // Use the pairId from the item
    card.dataset.icon = item.emoji;
    card.dataset.name = item.name;
    
    card.innerHTML = `
        <div class="memory-card-front">
            <div class="memory-animal">${item.emoji}</div>
            <div class="memory-name">${item.name}</div>
        </div>
        <div class="memory-card-back">ðŸŽ¯</div>
    `;
    
    card.addEventListener('click', flipCard);
    return card;
}

/* ================================================
   CARD FLIP LOGIC
   ================================================ */

/**
 * Handles card flip interaction
 */
function flipCard() {
    // Guard clauses
    if (gameState.lockBoard) return;
    if (this === gameState.firstCard) return;
    if (this.classList.contains('matched')) return;
    
    // Flip the card
    this.classList.add('flipped');
    playSound('flip');
    
    // First card selection
    if (!gameState.firstCard) {
        gameState.firstCard = this;
        return;
    }
    
    // Second card selection
    gameState.secondCard = this;
    gameState.lockBoard = true;
    
    checkForMatch();
}

/**
 * Checks if two flipped cards match
 */
function checkForMatch() {
    const isMatch = gameState.firstCard.dataset.pairId === gameState.secondCard.dataset.pairId;
    
    if (isMatch) {
        handleMatch();
    } else {
        handleMismatch();
    }
}

/**
 * Handles when cards match
 */
function handleMatch() {
    // Update scores
    gameState.scores[gameState.currentPlayer]++;
    gameState.pairsFound++;
    
    // Visual feedback
    gameState.firstCard.classList.add('matched');
    gameState.secondCard.classList.add('matched');
    
    // Audio feedback
    playSound('correct');
    
    // Reset for next turn
    resetTurn();
    updateStatus();
    
    // Check for game completion
    if (gameState.pairsFound === gameState.totalPairs) {
        setTimeout(endGame, 500);
    }
}

/**
 * Handles when cards don't match
 */
function handleMismatch() {
    playSound('incorrect');
    
    // Visual feedback
    gameState.firstCard.classList.add('shake');
    gameState.secondCard.classList.add('shake');
    
    // Unflip after delay
    setTimeout(() => {
        gameState.firstCard.classList.remove('flipped', 'shake');
        gameState.secondCard.classList.remove('flipped', 'shake');
        
        // Next player's turn (if multiplayer)
        if (gameState.numPlayers > 1) {
            nextPlayer();
        }
        
        resetTurn();
    }, 1200);
}

/* ================================================
   GAME STATE MANAGEMENT
   ================================================ */

/**
 * Passes turn to next player (multiplayer)
 */
function nextPlayer() {
    gameState.currentPlayer = (gameState.currentPlayer + 1) % gameState.numPlayers;
    updateStatus();
}

/**
 * Resets turn variables
 */
function resetTurn() {
    gameState.firstCard = null;
    gameState.secondCard = null;
    gameState.lockBoard = false;
}

/**
 * Updates score display and current player
 */
function updateStatus() {
    if (!DOM.statusDisplay) return;
    
    // Build score text
    const scores = gameState.scores
        .map((score, i) => `Jogador ${i + 1}: ${score} pontos`)
        .join(' | ');
    
    // Add turn indicator for multiplayer
    const turnText = gameState.numPlayers > 1 
        ? `<br>Vez do Jogador ${gameState.currentPlayer + 1}`
        : '';
    
    DOM.statusDisplay.innerHTML = scores + turnText;
}

/**
 * Updates timer display (hard mode)
 */
function updateTimer() {
    if (!DOM.timerText) return;
    
    const minutes = Math.floor(gameState.timeLeft / 60);
    const seconds = gameState.timeLeft % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    DOM.timerText.textContent = timeString;
}

/**
 * Starts the countdown timer (hard mode)
 */
function startTimer() {
    const { time } = DIFFICULTY_CONFIG[gameState.difficulty];
    
    if (time === 0) {
        DOM.timerDisplay?.classList.add('hidden');
        return;
    }
    
    gameState.timeLeft = time;
    DOM.timerDisplay?.classList.remove('hidden');
    updateTimer();
    
    gameState.timer = setInterval(() => {
        gameState.timeLeft--;
        updateTimer();
        
        if (gameState.timeLeft <= 0) {
            clearInterval(gameState.timer);
            endGame();
        }
    }, 1000);
}

/* ================================================
   GAME LIFECYCLE
   ================================================ */

/**
 * Starts a new game
 */
function startGame() {
    // Reset state
    gameState.reset();
    
    // Initialize scores
    gameState.scores = Array(gameState.numPlayers).fill(0);
    gameState.isGameActive = true;
    
    // Create board
    createBoard();
    
    // Start timer if needed
    startTimer();
    
    // Update display
    updateStatus();
}

/**
 * Ends the game and shows results
 */
function endGame() {
    gameState.isGameActive = false;
    
    // Stop timer
    if (gameState.timer) {
        clearInterval(gameState.timer);
        gameState.timer = null;
    }
    
    // Audio feedback
    playSound('game_complete');
    
    // Save statistics
    saveGameStats();
    
    // Visual celebration
    showConfetti();
    
    // Display winner message
    displayWinner();
}

/**
 * Saves game statistics to localStorage
 */
function saveGameStats() {
    try {
        const stats = JSON.parse(localStorage.getItem('memoryStats') || '{}');
        const { theme, difficulty, numPlayers, scores, timeLeft } = gameState;
        
        // Initialize theme stats
        if (!stats[theme]) stats[theme] = {};
        if (!stats[theme][difficulty]) {
            stats[theme][difficulty] = { bestTime: Infinity, bestScore: 0 };
        }
        
        // Update best time (single player, hard mode only)
        if (numPlayers === 1 && difficulty === 'hard') {
            const timeTaken = DIFFICULTY_CONFIG.hard.time - timeLeft;
            if (timeTaken < stats[theme][difficulty].bestTime) {
                stats[theme][difficulty].bestTime = timeTaken;
            }
        }
        
        // Update best score
        const totalScore = scores.reduce((a, b) => a + b, 0);
        if (totalScore > stats[theme][difficulty].bestScore) {
            stats[theme][difficulty].bestScore = totalScore;
        }
        
        localStorage.setItem('memoryStats', JSON.stringify(stats));
    } catch (error) {
        console.error('Failed to save stats:', error);
    }
}

/**
 * Displays winner message
 */
function displayWinner() {
    if (!DOM.statusDisplay) return;
    
    let message = '';
    
    if (gameState.numPlayers > 1) {
        const maxScore = Math.max(...gameState.scores);
        const winners = gameState.scores
            .map((score, index) => score === maxScore ? index + 1 : -1)
            .filter(index => index !== -1);
        
        message = winners.length > 1
            ? `Fim de jogo! Empate entre os jogadores: ${winners.join(' e ')}!`
            : `Fim de jogo! O Jogador ${winners[0]} venceu!`;
    } else {
        message = 'ParabÃ©ns, vocÃª completou o jogo!';
    }
    
    DOM.statusDisplay.innerHTML = message;
}

/* ================================================
   EVENT LISTENERS & INITIALIZATION
   ================================================ */

/**
 * Sets up player selection buttons
 */
function setupPlayerButtons() {
    const buttons = document.querySelectorAll('.memory-player-btn, .config-btn[data-players]');
    
    buttons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active from all buttons
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Add active to clicked button
            this.classList.add('active');
            
            // Update state
            gameState.numPlayers = parseInt(this.dataset.players) || 1;
        });
    });
}

/**
 * Sets up difficulty selection buttons
 */
function setupDifficultyButtons() {
    const buttons = document.querySelectorAll('.memory-difficulty-btn, .config-btn[data-difficulty]');
    
    buttons.forEach(button => {
        button.addEventListener('click', function() {
            // Remove active from all buttons
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // Add active to clicked button
            this.classList.add('active');
            
            // Update state
            gameState.difficulty = this.dataset.difficulty || 'medium';
        });
    });
}

/**
 * Sets up theme selection
 */
function setupThemeSelect() {
    if (!DOM.themeSelect) return;
    
    DOM.themeSelect.addEventListener('change', function() {
        gameState.theme = this.value;
    });
}

/**
 * Sets up sound toggle
 */
function setupSoundToggle() {
    if (!DOM.soundToggle) return;
    
    DOM.soundToggle.addEventListener('change', function() {
        gameState.soundEnabled = this.checked;
    });
    
    // Initialize state
    gameState.soundEnabled = DOM.soundToggle.checked;
}

/**
 * Sets up navigation buttons using event delegation
 */
function setupNavigation() {
    if (!DOM.memoryView) return;
    
    DOM.memoryView.addEventListener('click', function(e) {
        const button = e.target.closest('button');
        if (!button) return;
        
        const handlers = {
            'start-game': () => {
                e.preventDefault();
                startGame();
                showMemoryGame();
            },
            'back-to-config': () => {
                e.preventDefault();
                showMemoryConfig();
            },
            'restart-game': () => {
                e.preventDefault();
                startGame();
            }
        };
        
        const handler = handlers[button.id];
        if (handler) handler();
    });
}

/**
 * Initialize all event listeners
 */
function initializeEventListeners() {
    setupPlayerButtons();
    setupDifficultyButtons();
    setupThemeSelect();
    setupSoundToggle();
    setupNavigation();
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', initializeEventListeners);

/* ================================================
   VISUAL EFFECTS
   ================================================ */

/**
 * Shows confetti animation
 */
function showConfetti() {
    const container = document.createElement('div');
    container.classList.add('confetti-container');
    
    // Create confetti pieces
    const fragment = document.createDocumentFragment();
    for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.classList.add('confetti');
        confetti.style.left = `${Math.random() * 100}vw`;
        confetti.style.animationDelay = `${Math.random() * 2}s`;
        fragment.appendChild(confetti);
    }
    
    container.appendChild(fragment);
    document.body.appendChild(container);
    
    // Clean up after animation
    setTimeout(() => {
        container.remove();
    }, 3000);
}

/* ================================================
   AUDIO SYSTEM (Web Audio API)
   ================================================ */

/**
 * Audio configurations for different sound types
 */
const SOUND_CONFIG = {
    flip: {
        type: 'square',
        frequency: 800,
        gain: 0.08,
        duration: 0.1
    },
    correct: {
        type: 'sine',
        notes: [783.99, 1046.50, 1318.51], // G5, C6, E6
        gain: 0.15,
        duration: 0.4,
        interval: 0.1
    },
    incorrect: {
        type: 'triangle',
        startFreq: 220.00, // A3
        endFreq: 110.00,   // A2
        gain: 0.12,
        duration: 0.3
    },
    game_complete: {
        type: 'sine',
        notes: [523.25, 659.25, 783.99, 1046.50], // C5, E5, G5, C6
        gain: 0.1,
        duration: 0.2,
        interval: 0.15
    }
};

/**
 * Plays a sound using Web Audio API
 * @param {string} type - Sound type (flip, correct, incorrect, game_complete)
 */
function playSound(type) {
    if (!gameState.soundEnabled) return;
    
    try {
        const config = SOUND_CONFIG[type];
        if (!config) return;
        
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        if (config.notes) {
            playNoteSequence(audioContext, config);
        } else if (config.startFreq && config.endFreq) {
            playSlidingNote(audioContext, config);
        } else {
            playSimpleNote(audioContext, config);
        }
    } catch (error) {
        // Silently fail if Web Audio API is not supported
        console.warn('Audio not supported:', error);
    }
}

/**
 * Plays a simple note
 */
function playSimpleNote(audioContext, config) {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = config.type;
    oscillator.frequency.setValueAtTime(config.frequency, audioContext.currentTime);
    gainNode.gain.setValueAtTime(config.gain, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + config.duration);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + config.duration);
}

/**
 * Plays a sliding note (pitch change)
 */
function playSlidingNote(audioContext, config) {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    
    oscillator.type = config.type;
    oscillator.frequency.setValueAtTime(config.startFreq, audioContext.currentTime);
    oscillator.frequency.exponentialRampToValueAtTime(config.endFreq, audioContext.currentTime + config.duration);
    gainNode.gain.setValueAtTime(config.gain, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + config.duration);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + config.duration);
}

/**
 * Plays a sequence of notes
 */
function playNoteSequence(audioContext, config) {
    config.notes.forEach((freq, index) => {
        const oscillator = audioContext.createOscillator();
        const gainNode = audioContext.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioContext.destination);
        
        const startTime = audioContext.currentTime + (index * config.interval);
        const endTime = startTime + config.duration;
        
        oscillator.type = config.type;
        oscillator.frequency.setValueAtTime(freq, startTime);
        gainNode.gain.setValueAtTime(config.gain, startTime);
        gainNode.gain.exponentialRampToValueAtTime(0.00001, endTime);
        
        oscillator.start(startTime);
        oscillator.stop(endTime);
    });
}